#!/usr/bin/env zshctl

# Parses somewhat like gnu getopt but without the completion of arguments,
# with the potential to the `--no-` toggle, but I haven't gotten around to it.
#
# Does implement counting, so `-vvv` can be three times as verbose, and toggling
# instead of flags so `-qq` can be quiet and then not-quiet, although I've never
# encountered that in the wild.

# Used require gnu-getopt, which would have been an annoyance on OS X. Since
# we've gone with `zsh` to make OS X happy, we can go further and remove this
# core `dotctl` component that would conflict with the OS X installed BSD
# `getopt`.

# Note that getopt requires you to eval to set the argument array so we decided
# to go nuts and generate a script that will set local variables or emit error
# messages if the argument parse fails.

# NB: We prepend `o_` because it looks reasonable and it can be annoying to have
# an array named `user` that is full of users where `user` is a better name for
# an iterator variable, and we don't want to add `users=u,user:@`, or do we?

# https://stackoverflow.com/a/4025065
dotctl_vercomp() {
    if [[ $1 == $2 ]]
    then
        return 0
    fi
    local IFS=.
    local i ver1=(${=1}) ver2=(${=2})
    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++))
    do
        ver1[i]=0
    done
    for ((i=1; i<=${#ver1[@]}; i++))
    do
        if [[ -z ${ver2[i]} ]]
        then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]}))
        then
            return 1
        fi
        if ((10#${ver1[i]} < 10#${ver2[i]}))
        then
            return 2
        fi
    done
    return 0
}

function dotctl:cidr {
    eval "$(dotctl_parse_arguments cidr "h,help" -- "$@")"
    [[ $# -eq 0 ]] && acrectl_usage gce_key

    inet_aton() {
        declare -a parts=( "${(Oa@s/./)1}" )
        local num=0 e=0 
        for quad in "${parts[@]}"; do
            num=$(( num + ( quad * ( 256 ** e ) ) ))
            let e++
        done
        print -R $num
    }

    inet_ntoa() {
        declare -a parts
        num=${1:-}
        for e in 3 2 1; do
            parts+=( $(( num / 256 ** e )) )
            num=$(( num % 256 ** e ))
        done
        parts+=( $num )
        print -R ${(j:.:)parts}
    }

    dotctl_next_command cidr_ "$@"
}

function dotctl:cidr:divvy {
    eval "$(dotctl_parse_arguments cidr_divvy -- "$@")"
    local cidr=${1:-} address bits
    shift

    # https://zsh.sourceforge.io/Doc/Release/Arithmetic-Evaluation.html
    address=${cidr%/*}
    bits=${cidr#*/}

    blocks=${1:-}
    shift

    let start=$(inet_aton $address)
    let stop=$(inet_aton $(dotctl_command_cidr_inc $cidr $blocks))

    let parent=$(( stop - start ))

    declare -a counts
    while (( $# != 0 )); do
        counts+=($(( parent / ( 1 << (32 - $1) ) )))
        parent=$(( 1 << (32 - $1) ))
        shift
    done

    counts+=($parent)

    print $cidr $(inet_ntoa $stop)/$bits "${counts[@]}"
}

function dotctl:cidr:inc {
    eval "$(args -- "$@")"
    local cidr=${1:-} address bits
    shift
    bits=${cidr#*/}
    address=${cidr%/*}
    local count=${1:-1}
    local int=$(inet_aton $address)
    while (( count != 0 )); do
        int=$(( int + (1 << (32 - bits)) ))
        let count--
    done
    print "$(inet_ntoa $int)/$bits"
}

function execute:kit:homebrew {
    eval "$(args -- "$@")"
    heredoc <<'    EOF'
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    EOF
}

function execute:kit:rustc {
    eval "$(args -- "$@")"
    heredoc <<'    EOF'
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    EOF
}

function execute:kit {
    eval "$(args -UC -- "$@")"
    delegate "$@"
}

function execute:hello {
    print 'hello, world'
}

function execute {
    eval "$(args -UC -- "$@")"
    delegate "$@"
}
